{"version":3,"sources":["src/annotation.js"],"names":[],"mappings":";;;;;;;;;;;QAAa,UAAU;AACR,iBADF,UAAU,CACP,IAAI,EAAE,SAAS,EAAE;kCADpB,UAAU;;AAEf,gBAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,gBAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;;;AAI3B,gBAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;SACxC;;qBARQ,UAAU;;mBAUD,8BAAG;AACjB,oBAAI,MAAM,GAAG,EAAE,CAAC;AAChB,oBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,sBAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAK;AACzC,0BAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;iBACpC,CAAC,CAAC;AACH,uBAAO,MAAM,CAAC;aACjB;;;iBAEa,YAAG;AACb,uBAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;aAC1C;;;iBAEa,YAAG;AACb,uBAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;aAC1C;;;iBAEe,YAAG;AACf,uBAAO,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,EAAE,CAAC;aAC5C;;;;;;;;;mBAOQ,mBAAC,MAAM,EAAE,EAAE;;;;;;;;;;;;mBAUE,gCAAC,QAAQ,EAAE,QAAQ,EAAE;AACvC,oBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;;AAEjC,sBAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,KAAK,EAAK;AAChD,0BAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE;AACrC,6BAAK,EAAE,QAAQ,CAAC,KAAK,CAAC;qBACzB,CAAC,CAAC;iBACN,CAAC,CAAC;;AAEH,sBAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,aAAa,EAAE;AAC3C,yBAAK,EAAE,IAAI;iBACd,CAAC,CAAC;aACN;;;;;;;;;mBAOc,yBAAC,QAAQ,EAAE;AACtB,oBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;;;;;;AACjC,yCAAsB,UAAU,8HAAE;4BAAzB,SAAS;;AACd,4BAAI,SAAS,CAAC,QAAQ,YAAY,QAAQ,EAAE;AACxC,qCAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;yBAChC;qBACJ;;;;;;;;;;;;;;;aACJ;;;;;;;;mBAMmB,8BAAC,SAAS,EAAE;AAC5B,oBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;;;;;;AACjC,0CAAsB,UAAU,mIAAE;4BAAzB,SAAS;;AACd,4BAAI,SAAS,CAAC,aAAa,YAAY,QAAQ,EAAE;AAC7C,qCAAS,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;yBACtC;qBACJ;;;;;;;;;;;;;;;aACJ;;;;;;;;;mBAOoB,0BAAe;oBAAd,OAAO,gCAAG,EAAE;;AAC9B,oBAAI,KAAK,GAAG,EAAE,CAAC;;;;;;AACf,0CAAgB,OAAO,mIAAE;4BAAhB,GAAG;;AACR,4BAAI,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC;AAChC,4BAAI,UAAU,EAAE;AACZ,iCAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;yBACtC;qBACJ;;;;;;;;;;;;;;;;AACD,uBAAO,KAAK,CAAC;aAChB;;;eArGQ,UAAU;;;YAAV,UAAU,GAAV,UAAU;yBAuGR,UAAU","file":"src/annotation.js","sourcesContent":["export class Annotation {\n    constructor(name, targetCls) {\n        this.name = name;\n        this.targetCls = targetCls;\n\n        // We allow the decorators to decorate the targetCls\n        // before we create and configure the module\n        this.applyClassDecorators(targetCls);\n    }\n\n    getInjectionTokens() {\n        var tokens = [];\n        var injections = this.injections;\n        Object.keys(injections).forEach((binding) => {\n            tokens.push(injections[binding]);\n        });\n        return tokens;\n    }\n\n    get injections() {\n        return this.targetCls.injections || {};\n    }\n\n    get decorators() {\n        return this.targetCls.decorators || [];\n    }\n\n    get dependencies() {\n        return this.targetCls.dependencies || [];\n    }\n\n    /**\n     * This method can be overriden by child classes to\n     * configure the angular module after it is created\n     * @param {module} module The created angular module\n     */\n    configure(module) {}\n\n    /**\n     * This method applies all the requested injection bindings\n     * from the targetCls to the created instance\n     * @param  {Object} instance The created instance that\n     * wants the bindings\n     * @param  {Array<>} injected An array with the injected\n     * instances that we will apply on the class instance\n     */\n    applyInjectionBindings(instance, injected) {\n        var injections = this.injections;\n\n        Object.keys(injections).forEach((binding, index) => {\n            Object.defineProperty(instance, binding, {\n                value: injected[index]\n            });\n        });\n\n        Object.defineProperty(instance, '_annotation', {\n            value: this\n        });\n    }\n\n    /**\n     * This method decorates the created instance with all the\n     * targetCls decorators\n     * @param  {Object} instance The created instance to be decorated\n     */\n    applyDecorators(instance) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorate instanceof Function) {\n                decorator.decorate(instance);\n            }\n        }\n    }\n\n    /**\n     * This method decorates the class with all the targetCls decorators\n     * @param  {Object} targetCls The targetCls to be decorated\n     */\n    applyClassDecorators(targetCls) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorateClass instanceof Function) {\n                decorator.decorateClass(targetCls);\n            }\n        }\n    }\n\n    /**\n     * Returns all the angular module names for an array of classes\n     * @param  {Array} classes An array of classes you want to module names for\n     * @return {Array} The name of the angular modules for these classes\n     */\n    static getModuleNames(classes = []) {\n        var names = [];\n        for (let cls of classes) {\n            let annotation = cls.annotation;\n            if (annotation) {\n                names.push(annotation.module.name);\n            }\n        }\n        return names;\n    }\n}\nexport default Annotation;\n"]}