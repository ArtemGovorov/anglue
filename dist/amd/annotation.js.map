{"version":3,"sources":["src/annotation.js"],"names":[],"mappings":";;;;;;;QAAa,UAAU,WAAV,UAAU;AACR,iBADF,UAAU,CACP,IAAI,EAAE,SAAS;kCADlB,UAAU;;AAEf,gBAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,gBAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;;;AAI3B,gBAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;SACxC;;6BARQ,UAAU;AA4FZ,0BAAc;;;;;;;uBAAA,0BAAe;wBAAd,OAAO,gCAAG,EAAE;AAC9B,wBAAI,KAAK,GAAG,EAAE,CAAC;AACf,yCAAgB,OAAO;4BAAd,GAAG;AACR,4BAAI,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC;AAChC,4BAAI,UAAU,EAAE;AACZ,iCAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;yBACtC;qBACJ;AACD,2BAAO,KAAK,CAAC;iBAChB;;;;;AA3FD,8BAAkB;uBAAA,8BAAG;AACjB,wBAAI,MAAM,GAAG,EAAE,CAAC;AAChB,wBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,0BAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAK;AACzC,8BAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;qBACpC,CAAC,CAAC;AACH,2BAAO,MAAM,CAAC;iBACjB;;;;AAEG,sBAAU;qBAAA,YAAG;AACb,2BAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;iBAC1C;;;AAEG,sBAAU;qBAAA,YAAG;AACb,2BAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;iBAC1C;;;AAEG,wBAAY;qBAAA,YAAG;AACf,2BAAO,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,EAAE,CAAC;iBAC5C;;;AAOD,qBAAS;;;;;;;uBAAA,mBAAC,MAAM,EAAE,EAAE;;;;AAUpB,kCAAsB;;;;;;;;;;uBAAA,gCAAC,QAAQ,EAAE,QAAQ,EAAE;AACvC,wBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;;AAEjC,0BAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,KAAK,EAAK;AAChD,8BAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE;AACrC,iCAAK,EAAE,QAAQ,CAAC,KAAK,CAAC;yBACzB,CAAC,CAAC;qBACN,CAAC,CAAC;;AAEH,0BAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,aAAa,EAAE;AAC3C,6BAAK,EAAE,IAAI;qBACd,CAAC,CAAC;iBACN;;;;AAOD,2BAAe;;;;;;;uBAAA,yBAAC,QAAQ,EAAE;AACtB,wBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,yCAAsB,UAAU;4BAAvB,SAAS;AACd,4BAAI,SAAS,CAAC,QAAQ,YAAY,QAAQ,EAAE;AACxC,qCAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;yBAChC;qBACJ;iBACJ;;;;AAMD,gCAAoB;;;;;;uBAAA,8BAAC,SAAS,EAAE;AAC5B,wBAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,yCAAsB,UAAU;4BAAvB,SAAS;AACd,4BAAI,SAAS,CAAC,aAAa,YAAY,QAAQ,EAAE;AAC7C,qCAAS,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;yBACtC;qBACJ;iBACJ;;;;;;eArFQ,UAAU;;yBAuGR,UAAU","file":"src/annotation.js","sourcesContent":["export class Annotation {\n    constructor(name, targetCls) {\n        this.name = name;\n        this.targetCls = targetCls;\n\n        // We allow the decorators to decorate the targetCls\n        // before we create and configure the module\n        this.applyClassDecorators(targetCls);\n    }\n\n    getInjectionTokens() {\n        var tokens = [];\n        var injections = this.injections;\n        Object.keys(injections).forEach((binding) => {\n            tokens.push(injections[binding]);\n        });\n        return tokens;\n    }\n\n    get injections() {\n        return this.targetCls.injections || {};\n    }\n\n    get decorators() {\n        return this.targetCls.decorators || [];\n    }\n\n    get dependencies() {\n        return this.targetCls.dependencies || [];\n    }\n\n    /**\n     * This method can be overriden by child classes to\n     * configure the angular module after it is created\n     * @param {module} module The created angular module\n     */\n    configure(module) {}\n\n    /**\n     * This method applies all the requested injection bindings\n     * from the targetCls to the created instance\n     * @param  {Object} instance The created instance that\n     * wants the bindings\n     * @param  {Array<>} injected An array with the injected\n     * instances that we will apply on the class instance\n     */\n    applyInjectionBindings(instance, injected) {\n        var injections = this.injections;\n\n        Object.keys(injections).forEach((binding, index) => {\n            Object.defineProperty(instance, binding, {\n                value: injected[index]\n            });\n        });\n\n        Object.defineProperty(instance, '_annotation', {\n            value: this\n        });\n    }\n\n    /**\n     * This method decorates the created instance with all the\n     * targetCls decorators\n     * @param  {Object} instance The created instance to be decorated\n     */\n    applyDecorators(instance) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorate instanceof Function) {\n                decorator.decorate(instance);\n            }\n        }\n    }\n\n    /**\n     * This method decorates the class with all the targetCls decorators\n     * @param  {Object} targetCls The targetCls to be decorated\n     */\n    applyClassDecorators(targetCls) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorateClass instanceof Function) {\n                decorator.decorateClass(targetCls);\n            }\n        }\n    }\n\n    /**\n     * Returns all the angular module names for an array of classes\n     * @param  {Array} classes An array of classes you want to module names for\n     * @return {Array} The name of the angular modules for these classes\n     */\n    static getModuleNames(classes = []) {\n        var names = [];\n        for (let cls of classes) {\n            let annotation = cls.annotation;\n            if (annotation) {\n                names.push(annotation.module.name);\n            }\n        }\n        return names;\n    }\n}\nexport default Annotation;\n"]}