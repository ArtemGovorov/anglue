{"version":3,"sources":["src/annotation.js"],"names":[],"mappings":";;;+CAAa,UAAU;;;;;;;;AAAV,sBAAU;AACR,yBADF,UAAU,CACP,IAAI,EAAE,SAAS;0CADlB,UAAU;;AAEf,wBAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,wBAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;;;AAI3B,wBAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;iBACxC;;qCARQ,UAAU;AA4FZ,kCAAc;;;;;;;+BAAA,0BAAe;gCAAd,OAAO,gCAAG,EAAE;AAC9B,gCAAI,KAAK,GAAG,EAAE,CAAC;AACf,iDAAgB,OAAO;oCAAd,GAAG;AACR,oCAAI,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC;AAChC,oCAAI,UAAU,EAAE;AACZ,yCAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iCACtC;6BACJ;AACD,mCAAO,KAAK,CAAC;yBAChB;;;;;AA3FD,sCAAkB;+BAAA,8BAAG;AACjB,gCAAI,MAAM,GAAG,EAAE,CAAC;AAChB,gCAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,kCAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAK;AACzC,sCAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;6BACpC,CAAC,CAAC;AACH,mCAAO,MAAM,CAAC;yBACjB;;;;AAEG,8BAAU;6BAAA,YAAG;AACb,mCAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;yBAC1C;;;AAEG,8BAAU;6BAAA,YAAG;AACb,mCAAO,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,EAAE,CAAC;yBAC1C;;;AAEG,gCAAY;6BAAA,YAAG;AACf,mCAAO,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,EAAE,CAAC;yBAC5C;;;AAOD,6BAAS;;;;;;;+BAAA,mBAAC,MAAM,EAAE,EAAE;;;;AAUpB,0CAAsB;;;;;;;;;;+BAAA,gCAAC,QAAQ,EAAE,QAAQ,EAAE;AACvC,gCAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;;AAEjC,kCAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,KAAK,EAAK;AAChD,sCAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE;AACrC,yCAAK,EAAE,QAAQ,CAAC,KAAK,CAAC;iCACzB,CAAC,CAAC;6BACN,CAAC,CAAC;;AAEH,kCAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,aAAa,EAAE;AAC3C,qCAAK,EAAE,IAAI;6BACd,CAAC,CAAC;yBACN;;;;AAOD,mCAAe;;;;;;;+BAAA,yBAAC,QAAQ,EAAE;AACtB,gCAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,iDAAsB,UAAU;oCAAvB,SAAS;AACd,oCAAI,SAAS,CAAC,QAAQ,YAAY,QAAQ,EAAE;AACxC,6CAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;iCAChC;6BACJ;yBACJ;;;;AAMD,wCAAoB;;;;;;+BAAA,8BAAC,SAAS,EAAE;AAC5B,gCAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,iDAAsB,UAAU;oCAAvB,SAAS;AACd,oCAAI,SAAS,CAAC,aAAa,YAAY,QAAQ,EAAE;AAC7C,6CAAS,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;iCACtC;6BACJ;yBACJ;;;;;;uBArFQ,UAAU;;+BAuGR,UAAU","file":"src/annotation.js","sourcesContent":["export class Annotation {\n    constructor(name, targetCls) {\n        this.name = name;\n        this.targetCls = targetCls;\n\n        // We allow the decorators to decorate the targetCls\n        // before we create and configure the module\n        this.applyClassDecorators(targetCls);\n    }\n\n    getInjectionTokens() {\n        var tokens = [];\n        var injections = this.injections;\n        Object.keys(injections).forEach((binding) => {\n            tokens.push(injections[binding]);\n        });\n        return tokens;\n    }\n\n    get injections() {\n        return this.targetCls.injections || {};\n    }\n\n    get decorators() {\n        return this.targetCls.decorators || [];\n    }\n\n    get dependencies() {\n        return this.targetCls.dependencies || [];\n    }\n\n    /**\n     * This method can be overriden by child classes to\n     * configure the angular module after it is created\n     * @param {module} module The created angular module\n     */\n    configure(module) {}\n\n    /**\n     * This method applies all the requested injection bindings\n     * from the targetCls to the created instance\n     * @param  {Object} instance The created instance that\n     * wants the bindings\n     * @param  {Array<>} injected An array with the injected\n     * instances that we will apply on the class instance\n     */\n    applyInjectionBindings(instance, injected) {\n        var injections = this.injections;\n\n        Object.keys(injections).forEach((binding, index) => {\n            Object.defineProperty(instance, binding, {\n                value: injected[index]\n            });\n        });\n\n        Object.defineProperty(instance, '_annotation', {\n            value: this\n        });\n    }\n\n    /**\n     * This method decorates the created instance with all the\n     * targetCls decorators\n     * @param  {Object} instance The created instance to be decorated\n     */\n    applyDecorators(instance) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorate instanceof Function) {\n                decorator.decorate(instance);\n            }\n        }\n    }\n\n    /**\n     * This method decorates the class with all the targetCls decorators\n     * @param  {Object} targetCls The targetCls to be decorated\n     */\n    applyClassDecorators(targetCls) {\n        var decorators = this.decorators;\n        for (let decorator of decorators) {\n            if (decorator.decorateClass instanceof Function) {\n                decorator.decorateClass(targetCls);\n            }\n        }\n    }\n\n    /**\n     * Returns all the angular module names for an array of classes\n     * @param  {Array} classes An array of classes you want to module names for\n     * @return {Array} The name of the angular modules for these classes\n     */\n    static getModuleNames(classes = []) {\n        var names = [];\n        for (let cls of classes) {\n            let annotation = cls.annotation;\n            if (annotation) {\n                names.push(annotation.module.name);\n            }\n        }\n        return names;\n    }\n}\nexport default Annotation;\n"]}